use anyhow::{Result, anyhow};
use std::collections::HashMap;

fn day1() -> Result<()> {
  let contents = std::fs::read("./src/input.txt")?;

  let string = std::str::from_utf8(&contents)?;

  let lines = string.lines();

  let mut lefts: Vec<&str> = vec![];
  let mut rights: Vec<&str> = vec![];
  let mut rights_count: HashMap<&str, i32> = HashMap::new();

  for line in lines {
    let split: Vec<&str> = line.split("   ").collect();

    let left = *split.get(0).ok_or(anyhow!("expected left"))?;

    lefts.push(left);

    let right = *split.get(1).ok_or(anyhow!("expected right"))?;

    rights.push(right);
    *rights_count.entry(right).or_insert(0) += 1;
  }

  lefts.sort();
  rights.sort();

  let lefts_iter = lefts.iter();
  let rights_iter = rights.iter();
  let zip_iter = lefts_iter.zip(rights_iter);

  let mut total_diff: i32 = 0;
  let mut total_similarity_score = 0;

  for (left, right) in zip_iter {
    let left_num: i32 = left.parse()?;
    let right_num: i32 = right.parse()?;

    let mut diff = 0;

    if left_num > right_num {
      diff = left_num - right_num;
    } else if left_num < right_num {
      diff = right_num - left_num;
    }

    total_diff += diff;
  };

  for left in lefts {
    let mut count = 0;

    if let Some(right_count) = rights_count.get(left) {
      count = *right_count;
    }

    let num: i32 = left.parse()?;


    total_similarity_score += num * count;
  };

  println!("{:#?}", total_diff);
  println!("{:#?}", total_similarity_score);

  Ok(())
}


fn day2() -> Result<()> {
  println!("started");

  let contents = std::fs::read("./src/input2.txt")?;

  let string = std::str::from_utf8(&contents)?;

  let reports = string.lines();

  let mut safes = 0;

  'outer: for report in reports {
    let numbers_result: Result<Vec<_>, _> = report
      .split(" ")
      .map(|str| str.parse::<i32>())
      .collect();

    let numbers = numbers_result?;
    let mut prev = numbers[0];
    let mut prev_prev: Option<i32> = None;
    let mut increasing_opt: Option<bool> = None;
    let mut bad_levels_remaining: i32 = 1;

    for number in &numbers[1..] {
      let mut is_bad_level = false;

      if let None = increasing_opt {
        increasing_opt = Some(*number > prev);
      }

      if let Some(increasing) = increasing_opt {
        if !increasing && *number > prev {
          is_bad_level = true;
        } else if increasing && *number < prev {
          is_bad_level = true;
        }

        let diff = if increasing {
          *number - prev
        } else {
          prev - *number
        };

        if diff > 3 {
          is_bad_level = true;
        } else if diff == 0 {
          is_bad_level = true;
        }
      }

      if is_bad_level {
        bad_levels_remaining -= 1;
      }

      // if bad_levels_remaining == 1 {
        prev = *number;
      // }

      if bad_levels_remaining == -1 {
        continue 'outer;
      }

      // prev_prev = Some(prev);
    }

    println!("{:#?} is OK", report);
    safes += 1;
  }

  println!("{:#?}", safes);

  Ok(())
}

fn test() {
  let nums = vec![1,2,3,4,5];
  let nums2 = vec![1,2,3,4,5,6,7];

  'outer: for num in nums {
    for num2 in &nums2 {
      if *num2 == 3 {
        println!("it is 3, breaking outer.");

        break 'outer;
      }
      println!("{:#?}", *num2);
    }
  }
}

/*
we need to create a parser...
a parser, again, can be just

Parser<A> which can be thought of as a function

I -> (O, A)

where A is the result of the parser.

When combining parsers, however, the result is not used.
We pipe the output of each parser to the next one.
This way, we can create our own result (for example, a struct) while
parsing the intact string at the same time.
*/

type Parser<'a, A> = Box<dyn Fn(&'a str) -> anyhow::Result<(&'a str, A)> +'a>;

fn char<'a>(expected: char) -> Parser<'a, char> {
  Box::new(move |input: &'a str| {
    // TODO reread why can't index by integers, something to do
    // with how strings are encoded in Rust

    let head = input.chars().next().ok_or(anyhow!("expected a char"))?;
    let char_len_utf8 = head.len_utf8();

    if head == expected {
      Ok((&input[len_utf8..], head))
    } else {
      Err(anyhow!("{:#?} does not match {:#?}", head, expected))
    }
  })
}

fn day3() -> Result<()> {
  println!("Day 3!");

  let test_str = "abc";
  let p = char('a');

  let result = p(test_str);

  println!("{:#?}", result);

  Ok(())
}

fn main() -> Result<()> {
  day3();
  Ok(())
}
